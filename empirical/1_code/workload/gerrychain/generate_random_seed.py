import json
import numpy as np
import pickle
import os, re, math, time
from gerrychain.tree import recursive_tree_part,bipartition_tree_random
from gerrychain import Graph
import geopandas
'''
This code genrates a random seed plan 
that is valid on noisy counts generated by generate_dpcounts.py
The assignment plan is saves into json
The seeds can be used to run GerryChain Julia.
'''

#####################################################
#setup

NAME = 'redistricting/generate_random_seed'
PROJECT = 'ramm'

# set working directory
workdir = re.sub("(?<={})[\w\W]*".format(PROJECT), "", os.getcwd())
os.chdir(workdir)
# set up pipeline folder if missing
if os.path.exists(os.path.join('empirical', '2_pipeline')):
    pipeline = os.path.join('empirical', '2_pipeline', NAME)
else:
    pipeline = os.path.join('2_pipeline', NAME)
    
if not os.path.exists(pipeline):
    os.makedirs(pipeline)
    for folder in ['out', 'store', 'tmp']:
        os.makedirs(os.path.join(pipeline, folder))
        
######################################################

def get_params(state):
    
    params = {}
    #params['strategy'] = 'p-Identity (H)'
    #params['post-process'] = 'topdown'
    if state == 'IA':
        
        params['shapefile'] = 'empirical/0_data/external/IA-shapefiles/IA_counties/IA_counties.shp'
        params['pop column'] =  'TOTPOP'
        params['assignment column'] = 'CD'
        params['pop bound'] = 0.02
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_IA.json')
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_IA_'+params['post-process']+'.json')
        #params['output'] = os.path.join(pipeline, 'store', 'random_seed_IA.json')
        #params['output'] = os.path.join(pipeline, 'store', 'random_seed_IA_'+params['post-process']+'.json')
        params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'recom-pop-0.1-ep1e-06','dptotpop_IA_ls-round.json')
        params['output'] = os.path.join(pipeline, 'store', 'recom-pop-0.1-ep1e-06' ,'random_seed_IA')
        
    elif state == 'NC':
        
        params['shapefile'] = 'empirical/0_data/external/NC-shapefiles/NC_VTD/NC_VTD.shp'
        params['pop column'] =  'TOTPOP'
        params['assignment column'] = 'newplan'
        params['pop bound'] = 0.02
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_NC_topdown.json')
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_NC_ls-round.json')
        
        #params['output'] = os.path.join(pipeline, 'store', 'random_seed_NC') # dont need .json for excecute_alg
        params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'recom-pop-0.1-ep1e-06','dptotpop_NC_ls-round.json')
        params['output'] = os.path.join(pipeline, 'store', 'recom-pop-0.1-ep1e-06' ,'random_seed_NC')
        
    elif state == 'MA':
        
        params['shapefile'] = 'empirical/0_data/manual/MA-shapefiles/MA_no_islands_12_16_county/MA_precincts_12_16.shp'
        params['pop column'] =  'POP10'
        params['assignment column'] = 'CD'
        params['pop bound'] = 0.02
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_MA_ls-round.json')
        
        #params['output'] = os.path.join(pipeline, 'store', 'random_seed_MA') # dont need .json for excecute_alg
        params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store','dptotpop_MA_ls-round.json')
        params['output'] = os.path.join(pipeline, 'store' ,'random_seed_MA')
        
    elif state == 'CT':
        
        params['shapefile'] = 'empirical/0_data/external/CT-shapefiles/CT_precincts/CT_precincts.shp'  
        params['pop column'] =  'TOTPOP'
        params['assignment column'] = 'CD'
        params['pop bound'] = 0.02
        #params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store', 'dptotpop_CT_ls-round.json')
        
        #params['output'] = os.path.join(pipeline, 'store', 'random_seed_CT') # dont need .json for excecute_alg
        params['dpcountsfile'] = os.path.join('empirical', '2_pipeline', 'generate_dpcounts', 'store','dptotpop_CT_ls-round.json')
        params['output'] = os.path.join(pipeline, 'store' ,'random_seed_CT')
        
    elif state == 'TX':
        
        params['shapefile'] = 'empirical/0_data/external/TX-shapefiles/TX_vtds/TX_vtds.shp'
        params['pop column'] =  'TOTPOP'
        params['assignment column'] = 'USCD'
        params['pop bound'] = 0.02
        params['total steps'] = 10000
        

    return params

def execute(params):
    
    with open(params['dpcountsfile'],'r') as f:
        dpcounts = json.load(f)
    
    
    gdf = geopandas.read_file(params['shapefile']) 
    gdf['geometry'] = gdf.buffer(0)
    graph = Graph.from_geodataframe(gdf,ignore_errors=True)
    
    #start at 1 to match with julia indexing
    parts = [i+1 for i in range(len(gdf[params['assignment column']].unique()))] 
    print(parts)
    
    #graph = Graph.from_file(params['shapefile'],ignore_errors=True)
    
    
    
    results = {}
    
    for strategy in dpcounts.keys():
        #if strategy != 'Identity':
        #    continue
        results[strategy] = {}
        for post_process in dpcounts[strategy].keys():
            #if post_process != 'ls-round':
            #    continue
            results[strategy][post_process] = {}
            for eps in dpcounts[strategy][post_process].keys():
                #if eps == '1e-06':# or eps == '1e-05':
                #    continue
                #totpops = dpcounts[strategy][post_process][eps][params['pop column']]
                totpops = dpcounts[strategy][post_process][eps]
                results[strategy][post_process][eps] = {}
                results[strategy][post_process][eps][params['pop column']] = []
                
                count = 0
                print(strategy,post_process,eps)
                for i,xest in enumerate(totpops): #trails
                    if len(xest) == 1:
                        totpop = xest[0]
                    else:
                        totpop = xest.copy()
                    gdf['DPTOTPOP'] =  totpop
                    # add noisy populations to graph
                    graph.add_data(gdf,['DPTOTPOP']) 
                    ideal_population = sum(gdf['DPTOTPOP'].values) / len(parts)
                    #print(ideal_population)

                    print('generate random seed %d/%d'%(count,i))
                    seed = recursive_tree_part(
                        graph,
                        parts = parts, 
                        pop_target=ideal_population, 
                        pop_col='DPTOTPOP',
                        epsilon = params['pop bound'],
                        node_repeats=100, 
                        method = bipartition_tree_random
                    )
                    
                    
                    if seed is not None:
                        #check if it is valid
                        valid = True
                        pops = {part:0 for part in parts}
                        for node in seed:
                            pops[seed[node]] +=totpop[node]
                        min_pop,max_pop= (1-params['pop bound'])*ideal_population, (1+params['pop bound'])*ideal_population
                        for pop in pops.values():
                            if int(min_pop) > pop or int(max_pop) < pop: #invalid
                                print(pop,"invalid")
                                valid = False
                                break
                        #print(pops,valid,int(min_pop),int(max_pop))
                        if valid:
                            assignment = [seed[key] for key in sorted(seed)]
                            results[strategy][post_process][eps][params['pop column']].append((totpop,assignment))
                            count += 1
                    if count == 100:
                        break
                print(count)
                
    with open(params['output']+'.json', 'w') as f:
        json.dump(results, f,  indent=4)

def execute_alg(params,alg,post_process):
    
    with open(params['dpcountsfile'],'r') as f:
        dpcounts = json.load(f)
    
    
    gdf = geopandas.read_file(params['shapefile']) 
    
    #start at 1 to match with julia indexing
    parts = [i+1 for i in range(len(gdf[params['assignment column']].unique()))] 
    print(parts)
    
    gdf['geometry'] = gdf.buffer(0)
    graph = Graph.from_geodataframe(gdf,ignore_errors=True)
    #graph = Graph.from_file(params['shapefile'],ignore_errors=True)
     
    
    def run(strategy,post_process,eps):
        
        results = {}
        results[strategy] = {}
        results[strategy][post_process] = {}
        results[strategy][post_process][eps] = {}
        results[strategy][post_process][eps][params['pop column']] = []

        #totpops = dpcounts[strategy][post_process][eps][params['pop column']]
        totpops = dpcounts[strategy][post_process][eps]
        
                
        count = 0
        print(strategy,post_process,eps)
        for i, xest in enumerate(totpops): #trails
            if len(xest) == 1:
                totpop = xest[0]
            else:
                totpop = xest.copy()
            gdf['DPTOTPOP'] =  totpop
            # add noisy populations to graph
            graph.add_data(gdf,['DPTOTPOP']) 
            ideal_population = sum(gdf['DPTOTPOP'].values) / len(parts)

            print('generate random seed %d/%d'%(count,i))
            seed = recursive_tree_part(
                graph,
                parts = parts, 
                pop_target=ideal_population, 
                pop_col='DPTOTPOP',
                epsilon = params['pop bound'],
                node_repeats=100, 
                method = bipartition_tree_random
            )


            if seed is not None:
                #check if it is valid
                valid = True
                pops = {part:0 for part in parts}
                for node in seed:
                    pops[seed[node]] +=totpop[node]
                min_pop,max_pop= (1-params['pop bound'])*ideal_population, (1+params['pop bound'])*ideal_population
                for pop in pops.values():
                    if int(min_pop) > pop or int(max_pop) < pop: #invalid
                        print(pop,"invalid")
                        valid = False
                        break
                #print(pops,valid,int(min_pop),int(max_pop))
                if valid:
                    assignment = [seed[key] for key in sorted(seed)]
                    results[strategy][post_process][eps][params['pop column']].append((totpop,assignment))
                    count += 1
            if count == 100:
                break
        print(count)
        
        outputfile = params['output'] + '_' + strategy + '_' + post_process + '_' + eps + '.json'
        with open(outputfile, 'w') as f:
            json.dump(results, f,  indent=4)

    #alg = 'Identity'
    #alg = 'p-Identity'
    #post_process = 'ls-round'
    for eps in dpcounts[alg][post_process].keys():
        #if eps == '1e-06' or eps == '1e-05':
        #    continue
        #if eps == '1e-05':
        run(alg,post_process,eps)

def execute_gt(params):
    
    
    gdf = geopandas.read_file(params['shapefile']) 
    
    #start at 1 to match with julia indexing
    parts = [i+1 for i in range(len(gdf[params['assignment column']].unique()))] 
    print(parts)
    graph = Graph.from_file(params['shapefile'],ignore_errors=True)
     
    
    
    results = {}
    totpops = gdf[params['pop column']].values
    ideal_population = sum(totpops) / len(parts)
    while True:
        print('generate random seed')
        seed = recursive_tree_part(
            graph,
            parts = parts, 
            pop_target=ideal_population, 
            pop_col=params['pop column'],
            epsilon = params['pop bound'],
            node_repeats=100, 
            method = bipartition_tree_random
        )


        if seed is not None:
            #check if it is valid
            valid = True
            pops = {part:0 for part in parts}
            for node in seed:
                pops[seed[node]] +=totpops[node]
            min_pop,max_pop= (1-params['pop bound'])*ideal_population, (1+params['pop bound'])*ideal_population
            for pop in pops.values():
                if int(min_pop) > pop or int(max_pop) < pop: #invalid
                    print(pop,"invalid")
                    valid = False
                    break
            #print(pops,valid,int(min_pop),int(max_pop))
            if valid:
                assignment = [seed[key] for key in sorted(seed)]
                results['gt']=assignment
                break

    outputfile = params['output'] + '_gt.json'
    with open(outputfile, 'w') as f:
        json.dump(results, f,  indent=4)

if __name__=='__main__':
    
    #execute(get_params('IA'))
    #execute_alg(get_params('NC'),'p-Identity','ls-round')
    #execute_gt(get_params('NC'))
    
    #execute(get_params('IA'))
    #execute_alg(get_params('NC'),'toydown','hierarchy')
    #execute(get_params('IA'))
    #execute_alg(get_params('NC'),'p-Identity (H)','ls-round')
    #execute_alg(get_params('NC'),'equal','hierarchy')
    #execute_alg(get_params('NC'),'vtd-heavy4','hierarchy')

    
    #execute_alg(get_params('IA'),'Identity','ls-round')
    #execute_alg(get_params('NC'),'Identity','ls-round')
    #execute_alg(get_params('MA'),'Identity','ls-round')
    #execute_alg(get_params('CT'),'Identity','ls-round')

    #execute_alg(get_params('IA'),'p-Identity','ls-round')
    execute(get_params('IA'))
    #execute_alg(get_params('NC'),'p-Identity','ls-round')

